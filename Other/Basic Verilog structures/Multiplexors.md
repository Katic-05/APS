# Описание мультиплексора на языке Verilog

**Мультипле́ксор** — устройство, имеющее **несколько сигнальных входов**, **один или более управляющих входов** и **один выход**. Мультиплексор позволяет передавать сигнал **с одного из входов на выход**; при этом выбор желаемого входа осуществляется подачей соответствующей комбинации управляющих сигналов.

![](../../../technical/Labs/Pic/multiplexors_4.png)


Для начала создадим простой двухвходовый мультиплексор. Предположим, на `Y` нам необходимо передать один из сигналов — `D0` или `D1`. 

![](../../../technical/Labs/Pic/multiplexors_1.png)


Как понять, какой из сигналов и когда нужно подавать на `Y`? Для этого нам понадобится мультиплексор с  управляющим сигналом `S`.  Пусть, когда `S=0`, на `Y` подаётся сигнал `D0`, в противном случае — `D1`. 

![](../../../technical/Labs/Pic/multiplexors_2.png)

На верилоге это можно описать несколькими способами. Первый — **с помощью тернарного оператора**:

```Verilog
assign Y = S ? D1 : D0; // Y — это wire
```
Данное выражение говорит нам, что если S==1, то Y присваивается значение D1, в противном случае — значение D0. 

Также мультиплексор можно описать через **конструкцию if-else в блоке always**:

```Verilog
always @(*) begin  // * — значит реакция на любые изменения,
                   // то есть это комбинационная схема
  if(S) begin
    Y = D1;        // Y — это reg
  end else begin
    Y = D0;
  end
end
```

Мультиплексор также можно описать с использованием **конструкции case**.
Конструкция `case` представляет собой инструмент множественного ветвления, который сравнивает значение заданного выражения с множеством вариантов, и, в случае первого совпадения, использует соответствующую ветвь. На случай, если ни один из вариантов не совпадет с заданным выражением, конструкция `case` поддерживает вариант `default`. Данная конструкция аналогична оператору `switch-case` в Си, только используется для описания аппаратуры, в частности **мультиплексоров** и **дешифраторов**.
Реализация двухвходового мультиплексора с помощью `case` может выглядеть так:

```Verilog
always @(*) begin
  case(S)          // объявляем case и смотрим на значение S
    1'b0: Y = D0;  // Y — это reg. Если S==0, то Y = D2
    1'b1: Y = D1;  
  endcase          // закрываем case
end
```

<br>
Рассмотрим вариант посложнее и опишем следующую схему:


![](../../../technical/Labs/Pic/multiplexors_3.png)

Здесь уже используется мультиплексор 4-to-1. Управляющий сигнал `S` в данном случае двухбитный. В блоке case мы перечисляем всевозможные варианты значений `S` и описываем выход мультиплексора.


```Verilog
module test(
  input        A, 
  input        B, 
  input        C, 
  input        D, 
  input [1:0]  S, 

  output reg   Y

);
  always @(*) begin
    case(S)          
      2'b00:   Y = A;  
      2'b01:   Y = C | B;      // в выражении case можно мультиплексировать не только провода, 
                               // но и логические выражения
      2'b10:   Y = (C|B) & D;  
      2'b11:   Y = D;  
    endcase          
  end
endmodule
```

___
## Проверь себя

Как, по-вашему, описать на языке Verilog схему, приведённую ниже?

![](../../../technical/Labs/Pic/multiplexors_5.png)