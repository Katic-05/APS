# Однобитный счетчик
 Счётчик по тактовому синхроимпульсу суммирует своё предыдущее значение с заданным.

 Для создания однобитного счетчика нам понадобится **сумматор**, который будет складывать текущее значение счётчика с единицей:

  ![counter_1](../../../technical/Labs/Pic/counter_1.png)

 К нему подключим **триггер**, так как счетчик должен хранить значение, а суммировать по тактовому импульсу (`clk`):

 ![counter_2](../../../technical/Labs/Pic/counter_2.png)

 Такое устройство не будет работать без сигнала `rst`, т.к. у нас нет начального значения, с которого начинается отсчёт, поэтому добавим его:

 ![counter_3](../../../technical/Labs/Pic/counter_3.png)

 Подключим ко входу сумматора выход триггера `Q`, а  выход сумматора ко входу триггера `D`.

 ![counter_4](../../../technical/Labs/Pic/counter_4.png)

 Теперь **опишем это на Verilog**. На вход модуля сумматора подаётся тактовый сигнал `clk` и сигнал сброса `rst`. На выходе модуль выдаёт сигнал `Q`, каждый такт увеличивающий своё значение на 1. Сигнал `rst` сбрасывает значение триггера `Q` в 0.

```Verilog
module counter1(
  input        clk,
  input        rst,
  output reg   q
);
  always @(posedge clk) begin
    if(rst) begin
      q <= 1'b0;
    end else begin
      q <= q + 1'b1;
    end        
  end
endmodule
```

Посмотрим на **временную диаграмму** данного модуля. В начальный момент времени сигнал `rst` равен 1, поэтому значение `q` сбрасывается в ноль. Счётчик начинает считать, когда сигнал `rst` опускается в 0. Значение счётчика изменяется всякий раз, когда приходит положительный фронт сигнала `clk`.

![counter_5](../../../technical/Labs/Pic/counter_5.png)

В данном примере рассматривается однобитный счётчик, считающий от 0 до 1. Когда значение счётчика равно 1 и мы хотим прибавить к нему ещё 1, счетчик переполняется и его значение становится вновь равным нулю.

# Трёхбитный счётчик
Теперь реализуем трехбитный счетчик. Принцип реализации такой же, но сигнал `q` будет уже **трёхбитным**.

![counter_6](../../../technical/Labs/Pic/counter_6.png)

```Verilog
module counter1(
  input             clk,
  input             rst,
  output reg [2:0]  q
);
  always @(posedge clk) begin
    if(rst) begin
      q <= 3'b0;
    end else begin
      q <= q + 1'b1;
    end        
  end
endmodule
```
![counter_7](../../../technical/Labs/Pic/counter_7.png)

Теперь счётчик считает от 0 до 7. Дойдя до крайнего значения, он переполняется и становится равным 0, что показано на временной диаграмме.

Предположим, нам необходимо, чтобы счётчик считал не до 7, а до 5. В таком случае, когда счетчик равен пяти, он должен сбросить своё значение в ноль на следующем такте.

```Verilog
module counter1(
  input             clk,
  input             rst,
  output reg [2:0]  q
);
  always @(posedge clk) begin
    if(rst) begin
      q <= 3'b0;
    end else if(q == 'd5) begin
      q <= 3'b0;
    end else begin
      q <= q + 1'b1;
    end        
  end
endmodule
```

![counter_8](../../../technical/Labs/Pic/counter_8.png)

А схема преобразится следующим образом:

![counter_9](../../../technical/Labs/Pic/counter_9.png)

# Конкатенация
**Конкатенация** — объединение битов, находящихся в двух или более выражениях. Для записи конкатенации используются символы фигурных скобок `{` и `}`, с запятыми, отделяющими выражения, находящиеся в этих скобках. Следующий пример объединяет четыре выражения:

`{a, b[2:0], с, 4'b1101}`

Эта запись эквивалентна другой, приведённой ниже:

`{a, b[2], b[1], b[0], c, 1'b1, 1'b1, 1'b0, 1'b1}`

Конкатенации могут быть записаны с использованием **множителя повторения**:

`{5{a}}    // Это эквивалентно {a, a, a, a, a}`

Применение оператора конкатенации возможно с использованием **вложенных конкатенаций**. Число, указывающее, сколько раз надо повторить конкатенацию, должно быть постоянной величиной.

`{r, {3{a, b}}}    // Это эквивалентно  {r, a, b, a, b, a, b}`


# Проверь себя

1) Используя полученные знания, реализуйте на Verilog следующую схему:

![t-tr](../../../technical/Labs/Pic/counter_10.png)

2) Преобразуйте выражение, используя конкатенацию:

`{a[0], a[1:3], b[1], b[1], b[1], 2'd2, 2'd3, d}`