# Лабораторная работа 1 "Сумматор"

[\[Список лабораторных\]](../README.md) [\[СОДЕРЖАНИЕ\]](../../README.md)

## Цель

Познакомиться с САПР Vivado и научиться реализовывать в нём схемотехнические модули с помощью конструкций языка Verilog, а также писать к ним тестовое окружение на примере одноразрядного и многоразрядного сумматора.

## Допуск к лабораторной работе

Изучить [описание модулей на языке Verilog](../../Other/Basic%20Verilog%20structures/Modules.md).

## Ход работы

1.	Тренинг по созданию проекта в Vivado;
2.	Изучение, реализация и проверка полного однобитного сумматора;
3.  Изучение реализации полного четырехбитного сумматора;
4.	Реализация полного четырехбитного сумматора;
5.	Реализация 32-битного сумматора.
 
## Теория

Итогом лабораторной работы будет создание устройства, способного складывать два числа. Но перед тем, как учиться создавать подобное устройство, необходимо немного освоиться в самом процессе складывания чисел.

Давайте начнем с примера и сложим в столбик какую-нибудь пару чисел, например 42 и 79:

![](../../../technical/Labs/Pic/dec_column.png)

2 + 9 = 11	➨ 1 пишем, 1 "в уме".

4 + 7 = 11	➨ +1 "в уме" = 12 — 2 пишем, 1 "в уме".

0 + 0 = 0	➨ +1 "в уме" = 1.

Итого, 121.

Назовём то, что мы звали "1 в уме", переносом разряда.

Теперь попробуем сделать то же самое, только в двоичной системе исчисления. К примеру, над числами 3 и 5. Три в двоичной системе записывается как 011, Пять записывается как 101.

![](../../../technical/Labs/Pic/bin_column.png)

Поскольку в двоичной системе всего две цифры: 0 и 1, один разряд не может превысить 1. Складывая числа 1 и 1, вы получаете 2, что не умещается в один разряд, поэтому мы пишем 0 и 1 в уме. Это снова перенос разряда. Поскольку в двоичной арифметике разряд называют битом, перенос разряда называют переносом бита, а сам разряд, который перенесли — битом переноса.

### Полный однобитный сумматор

Полный однобитный сумматор — это цифровое устройство с тремя входными сигналами: операндами a, b и входным битом переноса, которое складывает их между собой, возвращая два выходных сигнала: однобитный результат суммы и выходной бит переноса. Что такое входной бит переноса? Давайте вспомним второй этап сложения чисел 42 и 79:

4 + 7 = 11, ➨ **+1 в уме** = 12 — 2 пишем, 1 в уме.

**+1 в уме** — это разряд, перенесённый с предыдущего этапа сложения.

Входной бит переноса — это разряд, перенесённый с предыдущего этапа сложения двоичных чисел. Имея этот сигнал, мы можем складывать многоразрядные двоичные числа путём последовательного соединения нескольких однобитных сумматоров: выходной бит переноса сумматора младшего разряда передастся на входной бит переноса сумматора старшего разряда.

### Реализация одноразрядного сложения

Можно ли как-то описать сложение двух одноразрядных двоичных чисел с помощью логических операций? Давайте посмотрим на таблицу истинности подобной операции

<img src="../../../technical/Labs/Pic/tt1.png" alt="Таблица истинности одноразрядного сложения" width="150"/>

<!-- |a|b| |<b>P</b>|<b>S</b>|
|-|-|-|--------|--------|
| | | |        |        |
|0|0| |<b>0</b>|<b>0</b>|
|0|1| |<b>0</b>|<b>1</b>|
|1|0| |<b>0</b>|<b>1</b>|
|1|1| |<b>1</b>|<b>0</b>| -->

*Таблица истинности одноразрядного сложения*

S — это цифра, записываемая непосредственно в столбце сложения под числами a и b. P — это цифра, записываемая левее, которая обычно записывается, если произошел перенос разряда. Как мы видим, перенос разряда происходит только в случае, когда оба числа одновременно равны единице. При этом в этот момент значение S обращается в 0, и результат записывается как 10, что в двоичной системе означает 2. Кроме того, S = 0 и в случае, когда оба операнда одновременно равны нулю. Вы можете заметить, что S = 0 в тех случаях, когда а и b равны, и не равно нулю в противоположном случае. Подобное свойство описывается логической операцией исключающее или:

<img src="../../../technical/Labs/Pic/tt2.png" alt="Таблица истинности операции Исключающее ИЛИ (XOR)" width="190"/>

*Таблица истинности операции Исключающее ИЛИ (XOR)*

Для бита переноса всё ещё проще — он описывается операцией логическое И:

<img src="../../../technical/Labs/Pic/tt3.png" alt="Таблица истинности операции И" width="160"/>

*Таблица истинности операции И*

Давайте нарисуем цифровую схему, связывающую входные и выходные сигналы с помощью логических элементов, соответствующих ожидаемому поведению:

![](../../../technical/Labs/Pic/1_fig-1.png) 

*Рисунок 1. Цифровая схема устройства, складывающего два операнда с сохранением переноса (полусумматора)*

Вроде все замечательно, но есть проблема. В описании полного однобитного сумматора сказано, что у него есть три входа, а в наших таблицах истинности и на схеме выше их только два. На самом деле, на каждом этапе сложения в столбик мы всегда складывали три числа: цифру верхнего числа, цифру нижнего числа, и единицу в случае переноса разряда из предыдущего столбца или ноль, в случае отсутствия переноса. Таким образом, таблицы истинности немного усложняются:

<img src="../../../technical/Labs/Pic/tt4.png" alt="Таблица истинности сигналов полного однобитного сумматора" width="250"/>

*Таблица истинности сигналов полного однобитного сумматора*

Поскольку теперь у нас есть и входной и выходной биты переноса, для их различия добавлены индексы “in” и “out”.

Как в таком случае описать S? Например, как `а ^ b ^ Ріn`, где `^` — операция исключающего ИЛИ. Давайте сравним такую операцию с таблицей истинности. Сперва вспомним, что Исключающее ИЛИ — ассоциативная операция [`(a^b)^c = a^(b^с)`], т.е. нам не важен порядок вычисления. Предположим, что Pin равен нулю. Исключающее ИЛИ с нулем дает второй операнд (`a^0=a`), значит `(a^b)^0 = a^b`. Это соответствует верхней половине таблицы истинности для сигнала S.

Предположим, что Pin равен единице. Исключающее ИЛИ с единицей дает нам отрицание второго операнда (`a^1=!a`), значит `(a^b)^1=!(a^b)`. Это соответствует нижней половине таблицы истинности.

Для выходного бита переноса всё гораздо проще. Он равен единице, когда хотя бы два из трех операндов равны единице, это значит что необходимо попарно сравнить все операнды, и если найдется хоть одна такая пара, он равен единице. Это утверждение можно записать следующим образом:

`Роut = (a&b) | (а&Pіn) | (b&Ріn)`, где `&` — логическое И, `|` — логическое ИЛИ.

Цифровая схема устройства с описанным поведением выглядит следующим образом:

![](../../../technical/Labs/Pic/1_fig-2.png)

*Рисунок 2. Цифровая схема полного однобитного сумматора*

## Практика

Реализуем схему полусумматора (рис.1) в виде модуля, описанного на языке Verilog.

Модуль half_adder имеет два входных сигнала и два выходных. Входы `А` и `В` идут на два логических элемента - `А` И `В` (А & В), `А` Исключающее ИЛИ `В` (А ^ В).

<details>

  <summary>Прочти меня перед использованием кода из примера.</summary>

### Во все примеры кода намеренно вставлены неподдерживаемые символы. Не копируй, одумайся!

  Важной частью изучения языка является практика по написанию кода. Даже если перепечатывая пример, вы не до конца его понимаете, вы запоминаете структуру кода и его конструкции. Вы изучаете этот пример для себя, а не для оценки, так что будьте честны с собой и воспроизведите пример самостоятельно.

<details>

  <summary> — Но мне очень надо.</summary>

  ![im watching you](../../../technical/Labs/Pic/im_watching_you.jpg)

</details>

<details>

  <summary> — Я переписал пример точь-в-точь, а он все равно не работает!</summary>

  Напишите кому-нибудь из [этого списка](../../Other/Teachers.md), вам обязательно помогут!

</details>

</details>

```systemverilog
module half_adder(
  input      A,   // Входные сигналы
  input      B,

  output     S,    // Выходной сигнал
  output     P

  );
  
  assign S = A ^ B;
  assign P = A & B;

  endmodule

```
*Листинг 1. Verilog-код модуля half_adder*

По данному коду, САПР сможет реализовать следующую схему:

![](../../../technical/Labs/Pic/example_vivado.png)

*Рисунок 3. Цифровая схема модуля half_adder, сгенерированная САПР Vivado*

Схема похожа на ту, что мы сделали сами, но как проверить, что эта схема не содержит ошибок и делает именно то, что от нее ожидается?

Для этого необходимо провести моделирование этой схемы. Во время моделирования на вход схемы подаются входные воздействия. Каждое изменение входных сигналов схемы приводит к каскадному изменению состояния внутренних цепей, которые в итоге меняют выходные сигналы.

Подаваемые на схему входные воздействия формируются верификационным окружением. Верификационное окружение (или тестбенч) — это особый несинтезируемый модуль, который не имеет входных или выходных сигналов. Ему не нужны входные сигналы, поскольку он сам является генератором всех своих внутренних сигналов, и ему не нужны выходные сигналы, поскольку этот модуль ничего не вычисляет, только подает входные воздействия на проверяемый модуль. Внутри тестбенча можно использовать конструкции из несинтезируемого подмножества языка Verilog, в частности программный блок `initial`, в котором команды выполняются последовательно, что делает тестбенч чем-то отдаленно похожим на проверяющую программу. Поскольку изменение внутренних цепей происходит с некоторой задержкой относительно изменений входных сигналов, при моделировании есть возможность делать паузы между командами. Это делается с помощью специального символа #, после которого стоит количество отсчётов времени симуляции, которое нужно пропустить перед следующей командой.

Перед тем как писать верификационное окружение, необходимо составить план того, как будет проводиться проверка устройства (составить верификационный план).

Поскольку устройство настолько простое, что число всех его возможных входных наборов воздействий равно восьми, и не имеет памяти (т.е. каждый раз, когда модулю подаются на вход одни и те же значения, оно вернет тот же результат), мы можем проверить его работу, перебрав все возможные варианты его работы.

```systemverilog
module testbench();                // <- Не имеет ни входов, ни выходов!
  reg a, b;
  wire p, s;

  half_adder DUT(                  // <- Подключаем проверяемый модуль
    .A    (a),
    .B    (b),
    .P    (p),
    .S    (s)
);

  initial begin
    a = 1'b0; b = 1'b0;            // <- Подаём на входы модуля тестовые
    #10;                           //    воздействия
    a = 1'b0; b = 1'b1; 
    #10;                           // <- Делаем паузу в десять отсчётов
    a = 1'b1; b = 1'b0;            //    времени симуляции перед очередным
    #10;                           //    изменением входных сигналов
    a = 1'b1; b = 1'b1; 
  end
endmodule
```
*Листинг 2. Verilog-код тестбенча для модуля example*

![](../../../technical/Labs/Pic/example_simulation.png)

*Рисунок 4. Временная диаграмма, моделирующая работу схемы с рис.3*

В данной лаборатной работе вам предстоит реализовать схему полного однобитного сумматора (_рис. 2_).

### Полный четырехбитный сумматор

Складывать несколько однобитных чисел не сильно впечатляет, поэтому сейчас мы займемся по-настоящему крутыми вещами — будем складывать пары четырехбитных чисел! Четырехбитные числа — это сила, они позволяют выбрать любое число от 0 до 15, а если сложить два числа с сохранением переноса, то вы получите диапазон результатов вплоть до 31! И вся эта вычислительная мощь будет у вас прямо под рукой — бери и пользуйся!
До этого мы реализовали только сложение одного столбца в столбик, теперь мы хотим реализовать всю операцию сложения в столбик. Как это сделать? Сделать ровно то, что делается при сложении в столбик: сначала сложить младший столбец, получить бит переноса для следующего столбца, сложить следующий и т.д. Давайте посмотрим, как это будет выглядеть на схеме (для простоты, внутренняя логика однобитного сумматора скрыта, но вы должны помнить, что каждый прямоугольник — это та же самая схема, что была представлена выше).

![](../../../technical/Labs/Pic/1_fig-5.png)

*Рисунок 5. Схема четырехбитного сумматора*

Фиолетовой линией на схеме показаны провода, соединяющие выходной бит переноса сумматора предыдущего разряда, с входным битом переноса сумматора следующего разряда.
Как же реализовать модуль, состоящий из цепочки других модулей? Половину этой задачи мы уже сделали, когда писали тестбенч к однобитному полусумматору в _Листинге 2_ — мы создавали модуль внутри другого модуля и подключали к нему провода. Теперь надо сделать то же самое, только с чуть большим числом модулей.

Но прежде чем мы это сделаем, нам нужно рассмотреть, что такое **вектор**.

### Векторы в Verilog

В Verilog **вектором** называют группу проводов или регистров, объединенных общим именем, которая может использоваться как для передачи многоразрядных чисел, так и нескольких сигналов, выполняющих общую задачу.

Синтаксис объявления вектора представлен ниже:

<pre>
<тип> [<старший индекс>:<младший индекс>] <i>имя_вектора</i>
</pre>

Несмотря на то, что может использоваться любой диапазон индексов (даже отрицательный), на практике стараются начинать младший индекс с нуля.  
Пример:

<pre>
<b>wire</b> [7:0] <i>sum</i>; // Объявляется 8-битный вектор с именем sum типа wire.
                // Старший индекс равен 7, младший — 0.
                // Векторы типа wire обычно называют "шиной"(bus).

<b>reg</b> [15:0] <i>Q</i>;   // В данной строке объявлен 16-битный вектор типа reg.
</pre>

Используя индекс, можно обратиться к отдельным битам вектора. С помощью диапазона индексов можно получить доступ к диапазону соответствующих битов.  

|фрагмент кода|описание|
|-------------|--------|
|sum[0];      | Обращение к младшему биту вектора sum, объявленного выше|
|Q[15:8];     | Обращение к старшим восьми битам 16-битного вектора Q, объявленного выше|

Теперь мы можем описать четырёхбитный сумматор, подключив четыре однобитных подобно тому, как было описано в [`документе`](../../Other/Basic%20Verilog%20structures/Modules.md#иерархия-модулей), который вы изучали перед лабораторной работой.

![](../../../technical/Labs/Pic/1_fig-6.png)

*Рисунок 6. Схема четырехбитного сумматора, сгенерированная САПР Vivado*

Схема может показаться запутанной, но если присмотреться, вы увидите, как от шин A, B и S отходят линии к каждому из сумматоров, а бит переноса передается от предыдущего сумматора к следующему.

## Задание

Вам необходимо реализовать полный 32-битный сумматор. Соединять вручную 32 однотипных модуля чревато усталостью и ошибками, поэтому можно, например, сначала создать 4-битный сумматор (либо другой разрядности), а затем из него сделать 32-битный. 

Далее идет пример того, как будет выглядеть заголовок модуля разрабатываемого устройства.

```systemverilog
module fulladder32(
    іnput [31:0] А,
    іnput [31:0] В,
    іnput        Pin,
    output[31:0] S,
    output       Pout
);
```

### Порядок выполнения задания

1. Согласно [руководству по созданию проекта в Vivado](../../Other/Vivado%20Basics/Vivado-trainer.md):
	1. Создайте проект;
	2. В `Design Sources` проекта создайте `Verilog`-файл `fulladder.v`.
2. Опишите в файле модуль `fulladder`, схема которого представлена на _Рис. 2_.
3. В `Simulation Sources` проекта создайте `Verilog`-файл `tb_fulladder`.
4. Вставьте содержимое файла [`tb_fulladder.v`](tb_fulladder.v), расположеного рядом с данным документом.
5. Запустите моделирование. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
6. Убедитесь, что модуль работает корректно и в консоль выдает `fulladder SUCCESS!!!`.
7. В `Design Sources` проекта создайте `Verilog`-файл `fulladder4`.
8. Опишите модуль `fulladder4`, схема которого представлена на _Рис. 5 и 6_, используя [`иерархию модулей`](../../Other/Basic%20Verilog%20structures/Modules.md#%D0%B8%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9), чтобы в нем выполнялось поразрядное сложение двух 4-битных чисел. Некоторые входы и выходы модуля будет необходимо описать в виде [`векторов`](#векторы-в-verilog).  
Модуль должен быть описан в соответствии со следующим прототипом:
    <details> 
    <summary>Прототип модуля.</summary>

    ``` verilog
    module fulladder4(
      input [3:0] A,
      input [3:0] B,
      input       Pin,
      output[3:0] S,
      output      Pout
    );
    ```

    </details>
9. Обратите внимание, что входной бит переноса должен подаваться на сумматор, выполняющий сложение нулевого разряда, выходной бит переноса соединяется с выходным битом переноса сумматора, выполняющего сложение 4-го разряда.
10. В `Simulation Sources` проекта создайте `Verilog`-файл `tb_fulladder4`.
11. Вставьте содержимое файла [`tb_fulladder4.v`](tb_fulladder4.v), расположеного рядом с данным документом.
12. Запустите моделирование. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
13. Убедитесь, что модуль работает корректно и в консоль выдает `fulladder4 SUCCESS!!!`.
14. В `Design Sources` проекта создайте `Verilog`-файл `fulladder32`.
15. Опишите модуль `fulladder32` так, чтобы в нем выполнялось поразрядное сложение двух 32-битных чисел. Его можно реализовать через последовательное соединение восьми 4-битных сумматоров, либо двух 16-битных, которые нужно реализовать, использовав 4 4-битных сумматоров.
    <details> 
    <summary>Как оптимизировать создание множества однотипных модулей.</summary>
    Для автоматизации подобной задачи существует блок generate, в частности — конструкция generate for, пример использования которой вы можете увидеть на изображении ниже (так же существуют конструкции generate if, generate case).
    
    ![](../../../technical/Labs/Pic/1_listing-4.png)

    *Рисунок 7. Пример использования конструкции generate for*

    Как вы можете догадаться, в этом примере создано 3 модуля, имена которых оканчиваются на значение итератора, по которому шел цикл, а к самим модулям подключены соответствующие итератору провода из шин. Разумеется, для своих целей вы можете использовать и **i+1** и двойные циклы. 

    Обратите внимание на `: newgen` стоящий после ключевого слова `begin`. В некоторых САПР, код может не собраться, если у конструкции `generate for` нет названия (**лейбла**) с помощью подобной записи (двоеточия и названия).

    **Обратите внимание**, что данный рисунок не является решением вашей задачи, поскольку у вашего сумматора три входа и два выхода, а у сумматора в примере нет бита переноса.
    </details>

15. Обратите внимание, что входной бит переноса должен подаваться на сумматор, выполняющий сложение нулевого разряда, выходной бит переноса соединяется с выходным битом переноса сумматора, выполняющего сложение 31-го разряда.
16. В `Simulation Sources` проекта создайте `Verilog`-файл `tb_fulladder32`.
17. Вставьте содержимое файла [`tb_fulladder32.v`](tb_fulladder32.v). Нажмите по нему в окне `Sources` ПКМ и выберите `Set as Top`.
18. Запустите моделирование.
19. Убедитесь, что модуль работает корректно.
20. Следующим шагом вы можете проверить работоспособность вашего дизайна на ПЛИС [здесь](board%20files).
