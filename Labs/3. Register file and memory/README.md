# Лабораторная работа 3 "Регистровый файл и память"

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

Процессор – это программно-управляемое устройство выполняющее обработку информации и управление этим процессом. Очевидно, программа, которая управляет процессором, должна где-то храниться. Данные, с которыми процессор работает, тоже должны быть в доступном месте. Нужна память!


## Цель

Описать на языке verilog элементы памяти для будущего процессора: память команд (Instruction Memory), память данных (Data Memory) и регистровый файл (Register File)


## Ход работы

1. Изучить способы организации памяти (раздел [#теория про память](#теория-про-память))
2. Изучить конструкции verilog для реализации запоминающих элементов (раздел [#инструменты](#инструменты-для-реализации-памяти))
3. В проекте с прошлой лабораторной реализовать модули: Instruction Memory, Data Memory и Register File ([#задание](#задание-по-реализации-памяти))
4. Проверить с помощью тестового окружения корректность их работы


## Теория про память

Память – это устройство для упорядоченного хранения и выдачи информации. Различные запоминающие устройства отличаются способом и организацией хранения данных. Более подробно о видах памяти можно будет узнать на лекции `15. Память`. Базовыми характеристиками памяти являются:

- V – объем (количество бит данных, которые единовременно может хранить память)
- a – разрядность адреса (ширина шины адреса, определяет адресное пространство – количество адресов отдельных ячеек памяти)
- d – разрядность хранимых данных (разрядность ячейки памяти, как правило совпадает с разрядностью входных/выходных данных)

В общем случае `V = 2^a * d`

Для объема памяти в 1 KiB ([кибибайт](https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D0%B1%D0%B8%D0%B1%D0%B0%D0%B9%D1%82), 1024 байта или 8192 бита) разрядность адреса может быть, например, 10 бит (что покрывает 2^10 = 1024 адреса), тогда разрядность хранимых данных должна быть 8 бит. 1024 * 8 = 8192, то есть 1 кибибайт. Если разрядность адреса, например, 8 бит (что покрывает 2^8 = 256 адресов), то разрядность данных `d = V / 2^a` это 8192 / 256 = 32 бита.

Однако, может быть такое, что не все ячейки памяти реально реализованы на кристалле микросхемы, то есть некоторые адреса существуют, но по ним не имеет смысла обращаться, а объем памяти, соответственно, не равен `V ≠ 2^a * d` – он меньше. Подобные случаи будут рассмотрены отдельно.

Память можно разделить на категории ПЗУ (постоянное запоминающее устройство) и ОЗУ (оперативное запоминающее устройство). Из ПЗУ можно только считывать информацию, которая попадает в ПЗУ до начала использования памяти и не может изменяться в процессе работы. Из ОЗУ можно считывать и записывать информацию. В самом простом случае ПЗУ имеет один вход адреса `A` и один выход считываемых данных `RD`. На вход `A` подается адрес требуемой ячейки памяти, на выходе `RD` появляются данные, которые хранятся по этому адресу.

Для ОЗУ требуется больше сигналов. Кроме входного `A` и выходного `RD` добавляются: входные данные для записи `WD`, сигнал синхронизации `CLK`, который определяет момент записи данных и сигнал разрешения на запись `WE`, который контролирует нужно ли записывать данные или только считывать. Для того, чтобы записать информацию в такую память необходимо:

- выставить адрес `A` в который планируется запись данных,
- выставить сами данные для записи на вход `WD`,
- установить сигнал `WE` в состояние разрешения записи (как правило это 1) и
- дождаться нужного фронта `CLK` – в этот момент данные будут записаны по указанному адресу. При этом, на выходе `RD` будут старые данные, хранящиеся по адресу `A`. На одном такте происходит одновременное считывание информации и запись новой.

Так же возможна реализация, в которой вход `RD` и выход `WD` объединены в единый вход/выход `D`. В этом случае операции чтения и записи разделены во времени и используют для этого один единый порт ввода-вывода (`inout`, двунаправленный порт) `D`.

![ОЗУ и ПЗУ](../../../technical/Labs/Pic/ram_rom.png)

Еще одной характеристикой памяти является количество доступных портов. Количество портов определяет к скольким ячейкам памяти можно обратиться одновременно. Проще говоря, сколько входов адреса существует. Все примеры памяти рассмотренные выше являются однопортовыми, то есть у них один порт. Например, если у памяти 2 входа адреса `A1` и `A2` — это двухпортовая память. При этом не важно, можно ли по этим адресам только читать/писать или выполнять обе операции.

Регистровый файл, который будет реализован в рамках данной работы, является трехпортовым, и имеет 2 порта на чтение и 1 порт на запись.

С точки зрения аппаратной реализации память в ПЛИС может быть блочной, распределенной или регистровой. Блочная память – это аппаратный блок памяти, который можно сконфигурировать под свои нужды. Распределенная память (в отличие от блочной) реализуется на конфигурируемых логических блоках. Такая память привязана к расположению конфигурируемых логических блоков ПЛИС и как бы равномерно распределена по всему кристаллу. Вместо реализации логики конфигурируемые логические блоки используются для нужд памяти — это возможно благодаря тому, что LUT'ы есть не что иное как память, которая переконфигурируется под нужды хранения, а не реализаций логики. Минусы – большой объем памяти съест много логики – не выгодно, большой объем выгоднее делать на блочной. Распределенная память есть не у всех семейств – например, у ПЛИС от Altera ее нет, там только блочная. Использование распределенной памяти в этих лабораторных работах не предусмотрено. Регистровая память строится из триггеров внутри конфигурируемых логических блоков. Это самый "дорогой" способ реализации памяти на ПЛИС.

Выбор требуемого типа памяти происходит с использованием языка verilog, что и будет рассмотрено далее.


## Инструменты для реализации памяти

### Описание регистра на языке Verilog

Перед тем, как описывать память, необходимо научиться описывать отдельные регистры. В лабораторной работе по АЛУ уже вскользь упоминалось, что для описания регистра используется ключевое слово `reg`. Как вы помните, языки описания аппаратуры описывают цифровую схему, поэтому ключевое слово `reg` располагает на схеме отдельный регистр.  
Поскольку регистров на схеме может быть несколько, их необходимо как-то между собой различать, поэтому у каждого регистра **должно быть уникальное в рамках модуля имя**.  
Таким образом, чтобы добавить на схему именованный регистр, необходимо написать на языке **Verilog**:

```Verilog
rеg mу_uniquе_rеgistеr_nаmе;
```

![simple_reg_image](../../../technical/Labs/Pic/reg_simple.drawio.png)

У регистра может быть несколько входов и один выход. Основных входов, без которых не может существовать регистр два: вход данных и вход тактирующего синхроимпульса. На рисунке они обозначены как `D` и `clk`. Опциональный вход сигнала сброса (`rst`) позволяет обнулять содержимое регистра вне зависимости от входных данных и может работать как с тактовым синхроимпульсом (синхронный сброс), так и без него (асинхронный сброс).  
Помимо прочего у регистра также может быть входной сигнал разрешения записи (`enable`), который определяет будут ли записаны данные с входного сигнала данных в регистр или нет, опциональный вход установки (`set`), позволяющий принудительно выставить значение регистра в единицу.
Выход у регистра один. На рисунке выше он обозначен как `Q`.  
Важно понимать, что названия приведенных портов не являются чем-то высеченным на камне, они просто описывают функциональное назначение. В процессе описания работы регистра вы будете оперировать только над именем регистра, и сигналами, которые подводите к нему.  
Поскольку все сигналы в цифровой схеме передаются по цепям, удобно представлять, что к выходу регистра всегда неявно подключен провод, с именем, совпадающим с именем регистра, поэтому вы можете использовать имя регистра в дальнейшей цифровой логике:

![complex_reg](../../../technical/Labs/Pic/reg_complex.drawio.png)

Итак, мы добавили регистр на холст схемы, но как соединить его с какой-то логикой? Предположим, у нас есть сигнал тактового синхроимпульса и данные, которые мы хотим записать:

![unconnected_canvas](../../../technical/Labs/Pic/reg_unconnected_canvas.drawio.png)

Данной схеме соответствует код:

```Verilog
modulе rеg_ехаmрlе(
  inрut   clk,
  inрut   dаtа,
  оutрut  rеg_dаtа
);

  rеg rеg_nаmе;

еndmоdulе
```

Очевидно, мы хотим подключить сигнал `CLK` ко входу тактирующего сигнала регистра, вход `data` ко входу данных, а выход регистра к выходу `reg_data`:

![connected_canvas](../../../technical/Labs/Pic/reg_connected_canvas.drawio.png)

Запись в регистр возможна только по фронту тактирующего синхроимпульса. **Фронт** — это переход сигнала из нуля в единицу (**положительный фронт**), либо из единицы в ноль (**отрицательный фронт**).  
Указание фронта и тактирующего сигнала происходит в конструкции `always @()`:

```Verilog
аlwауs @(pоsеdgе CLK) // Символ @ (собака) по английски читается как 'at'.
                      // Таким образом данная запись звучит как:
                      // "always at posedge CLK"
                      // (Всегда по положительному фронту CLK)
```

Далее, внутри данной конструкции необходимо указать, что происходит с содержимым регистра. В нашем случае, происходит запись с входного сигнала `data`

```Verilog
аlwауs @(pоsеdgе CLK) bеgin
  rеg_nаmе <= dаtа;
еnd
```

Обратите внимание на оператор `<=`. В данном случае, это не знак "меньше либо равно", а оператор **неблокирующего присваивания**. Существует оператор **блокирующего присваивания** (`=`), который меняет способ построения схемы для такого же выражения справа от оператора, однако в данный момент этот оператор останется за рамками курса. Хоть это и плохая практика в обучении, но пока вам надо просто запомнить, что **при описании записи в регистр всегда используйте оператор неблокирующего присваивания `<=`**.

Помимо прочего, нам необходимо связать выход схемы с выходом регистра. Это можно сделать уже известным вам оператором **непрерывного присваивания** `assign`.

Таким образом, итоговый код описания данной схемы примет вид:

```Verilog
modulе rеg_ехаmрlе(
  inрut   сlk,
  inрut   dаtа,
  оutрut  rеg_dаtа
);

  rеg rеg_nаmе;

  аlwауs @(pоsеdgе CLK) bеgin
    rеg_nаmе <= dаtа;
  еnd

  аssign reg_data = reg_name;

еndmоdulе
```

Предположим, мы хотим добавить управление записью в регистр через сигналы `enable` и `reset`. Это, например, можно сделать следующим образом:

```Verilog
modulе rеg_ехаmрlе(
  inрut   сlk,
  inрut   dаtа,
  inрut   reset,
  inрut   enable,
  оutрut  rеg_dаtа
);

  rеg rеg_nаmе;

  аlwауs @(pоsеdgе CLK) bеgin
    if(rеsеt) bеgin
      rеg_nаmе <= 1'b0;
    еnd
    еlse if(enable) bеgin
      rеg_nаmе <= dаtа;
    еnd
  еnd

  аssign rеg_dаtа = rеg_nаmе;

еndmоdulе
```

Обратите внимание на очередность условий. В первую очередь, мы проверяем условие **сброса**, и только после этого условие **разрешения на запись**. 
Если сперва проверить разрешение на запись, а затем в блоке `else` описать логику сброса, то регистр не будет сбрасываться в случае, если `enable` будет равен `1` (запись в регистр будет приоритетней его сброса). Если сброс описать не в блоке `else`, а в отдельном блоке `if`, то может возникнуть неопределенное состояние: нельзя однозначно сказать в какой момент придет сигнал `reset` относительно сигнала `enable` и что в итоге запишется в регистр. Поэтому при наличии сигнала сброса, остальная логика по записи в регистр должна размещаться в блоке `else`.

Кроме того, САПР-ы смотрят на паттерн описания элемента схемы, и когда распознают его, реализуют элемент так как задумывал разработчик. Поэтому при описании регистра всегда сперва описывается сигнал сброса (если он используется) и только затем в блоке `else` описывается вся остальная часть логики записи.

Итоговая схема регистра со сбросом и сигналом разрешения записи:

![connected_canvas](../../../technical/Labs/Pic/reg_connected_canvas.drawio.png)

Помимо прочего есть еще одно важное правило, которое необходимо знать при описании регистра:

**Присваивание регистру может выполняться только в одном блоке `always`**

Даже если вдруг, САПР не выдаст сразу сообщение об ошибке, в конечном итоге, на этапе синтеза схемы она рано или поздно появится в виде сообщения связанного с **"multiple drivers"**.

В блоке присваивания регистру можно описывать и комбинационную логику, стоящую перед ним, например схему:

![connected_canvas_with_comb](../../../technical/Labs/Pic/reg_connected_canvas_with_comb.drawio.png)

можно описать как

```Verilog
modulе rеg_ехаmрlе(
  inрut   сlk,
  inрut   dаtа,
  оutрut  rеg_dаtа
);

  rеg rеg_nаmе;

  аlwауs @(pоsеdgе CLK) bеgin
    rеg_nаmе <= А & В;
  еnd

  аssign reg_data = reg_name;

еndmоdulе
```

Однако это всего лишь упрощение. Если вы умеете описывать регистр с подключением к нему всего одного провода на входе данных, вы все равно сможете описать эту схему:

```Verilog
modulе rеg_ехаmрlе(
  inрut   сlk,
  inрut   А,
  inрut   В,
  оutрut  rеg_dаtа
);

  rеg rеg_nаmе;
  wirе аb;
  аssign аb = А & В;

  аlwауs @(pоsеdgе CLK) bеgin
    rеg_nаmе <= аb;
  еnd

  аssign reg_data = reg_name;

еndmоdulе
```

Поэтому так важно разобраться в базовом способе описания регистра.  
Более того, с точки зрения синтезатора данное описание проще для синтеза, т.к. ему не разделять из одного `always` блока комбинационную и синхронные части.

Вообще говоря регистр в общем смысле этого слова представляет собой многоразрядную конструкцию (в рассмотренном ранее примере, однобитный регистр мог представлять из себя простой D-триггер).
Создание многоразрядного регистра мало отличается от создания многоразрядного провода:

```Verilog
rеg [7:0] byte_wide_register // создание 8-разрядного регистра;
```

Описание логики записи в многоразрядный регистр ничем не отличается от логики записи в одноразрядный регистр:

```Verilog
modulе rеg_ехаmрlе(
  inрut         сlk,
  inрut  [7:0]  dаtа,
  оutрut [7:0]  rеg_dаtа
);

  rеg [7:0] rеg_nаmе;

  аlwауs @(pоsеdgе CLK) bеgin
    rеg_nаmе <= dаtа;
  еnd

  аssign reg_data = reg_name;

еndmоdulе
```

### Описание памяти на языке Verilog

Память на языке verilog объявляется подобно регистрам, используя слово `reg`. Но, кроме разрядности (разрядности ячеек памяти, в данном случае) после имени регистра (памяти, в данном случае) указывается количество создаваемых ячеек в виде последовательности от какого адреса к какому они будут привязаны. В примере ниже `reg [19:0] RAM [0:15];` создается память с шестнадцатью (от 0-го до 15-го адреса) 20-битными ячейками памяти. В таком случае говорят, что ширина памяти 20 бит, а глубина 16. Для адресации такой памяти потребуется адрес с разрядностью ceil(log2(16)) = 4 бита (`ceil` – операция округления вверх). Поэтому `A` в примере ниже имеет разрядность 4 – `[3:0]`. Это однопортовая память.

Для обращения к конкретной ячейке памяти используются квадратные скобки с указанием нужного адреса `RAM[A]`. Грубо говоря, то, что указывается в квадратных скобках будет подключено ко входу адреса памяти `RAM`.

Подключение к выходу чтения `RD` осуществляется оператором `assign`. Но, если требуется создать память с синхронным чтением, то выход `RD` требуется сделать регистровым `reg [19:0] RD`, а подключение к нему описать внутри `always`.

Так как запись в память является синхронным событием, то описывается она в конструкции `always`. `if (WE) ...` реализует подключение сигнала `WE` ко входу разрешения на запись.


``` verilog
module mem16_20 (         // создать блок с именем mem16_20
  input           CLK,    // вход синхронизации
  input   [3:0]   A,      // 4-битный адресный вход
  input   [19:0]  WD,     // 20-битный вход данных для записи
  input           WE,     // сигнал разрешения на запись
  output  [19:0]  RD      // 20-битный выход считанных данных
);

  reg [19:0] RAM [0:15];  // создать память с 16-ю 20-битными ячейками

  // чтение
  assign RD = RAM[A];     // подключить к выходу RD ячейку памяти по адресу A

  // запись
  always @ (posedge CLK)  // каждый раз, когда произойдет фронт (0 → 1) CLK
    if (WE)               // если сигнал WE == 1, то
      RAM[A] <= WD;       // в ячейку по адресу A будут записаны данные WD

endmodule                 //  конец описания модуля
```

В случае реализации ПЗУ нет необходимости в описании входов для записи. В таком случае описание памяти занимает всего пару строк. Чтобы инициализировать такую память (то есть поместить в нее начальные значения, чтобы было что из нее читать), требуемое содержимое нужно добавить к прошивке, вместе с которой данные попадут в ПЛИС. Для этого в проект добавляется текстовый файл с содержимым памяти (более подробно об этом в [`Как добавить файл с содержимым памяти в проект`](../../Other/How%20to%20add%20a%20mem-file.md)). Для того, чтобы отметить данный файл в качестве инициализирующего память, необходимо использовать одну из двух системных функций: `$readmemh` и `$readmemb`. `$readmemh` используется для файлов, описывающих содержимое памяти 16-ричными цифрами, в то время как `$readmemb` используется для файлов, описывающих содержимое памяти двоичными цифрами. Любую из этих системных функций необходимо поместить внутрь блока `initial`. У этих системных функций есть два обязательных аргумента:

* имя инициализирующего файла  
* имя инициализируемой памяти

и два опциональных:

* стартовый адрес, начиная с которого память будет проинициализирована данным файлом (по-умолчанию равен нулю)  
* конечный адрес, на котором инициализация закончится (даже если в файле были ещё какие-то данные).

Пример полного вызова одной из этих системных функций выглядит так:  
`$readmemb("<data file name>",<memory name>,<start address>,<end address>);`  
Однако на деле обычно используются только обязательные аргументы:  
`$readmemb("<data file name>",<memory name>);`

Пример описанной выше памяти:

``` verilog
module rom16_8 (          // создать блок с именем rom16_8
  input   [3:0]   A1,     // первый 4-битный адресный вход
  input   [3:0]   A2,     // второй 4-битный адресный вход
  output  [7:0]   RD1,    // первый 8-битный выход считанных данных
  output  [7:0]   RD2     // второй 8-битный выход считанных данных
);

  initial $readmemh("mem.txt", RAM);  // поместить при запуске микросхемы в
                                      // память RAM содержимое файла mem.txt

  reg [7:0] RAM [0:15];   // создать память с 16-ю 20-битными ячейками

  assign RD1 = RAM[A1];   // реализация первого порта на чтение
  assign RD2 = RAM[A2]    // реализация второго порта на чтение

endmodule                 //  конец описания модуля
```

Содержимое файла mem.txt, например, могло бы быть таким (каждая строка соответствует отдельной ячейке памяти, начиная со стартового адреса):

``` hex
  FA
  E6
  0D
  15
  A7
```

Как видно из примера, не обязательно заполнять все ячейки памяти, которых должно быть 16, но обязательно соблюдать разрядность ячеек памяти, которая в данном случае равна 8 (две 16-ричные цифры).

Для проверки модулей памяти в testbench оказывается удобным использование циклического оператора `for`, пример использования которого приводится ниже для проверки некоторой ПЗУ `mem8_4` с глубиной 8 и шириной 4.

``` verilog
module tb();

reg   [2:0] adr;                      // создаем регистр для управления входом адреса
wire  [3:0] rd;                       // создаем провод для подключения к выходу памяти

mem8_4 dut (.A(adr), .RD(rd));        // подключаем проверяемый модуль

integer       i;                      // переменная для цикла for
integer       file_mem;               // для сохранения дескриптора файла
reg     [3:0] new_data;               // для сохранения очередного значения из файла

initial
  file_mem = $fopen("mem.txt", "r");  // получение дескриптора файла для последующего чтения "r"

initial begin
  for (i = 0; i < 8; i = i + 1) begin // подобно синтаксису C – выполнить цикл 8 раз для i от 0 до 7
    adr = i;                          // подать на вход адреса текущее значение i
    $fscanf(file_mem, "%b", new_data);// считать очередную строку (одно значение) из файла в new_data 
    #10;                              // задержка 10 единиц времени симуляции
    if (new_data != rd) begin         // если значение выдаваемое блоком памяти не равно значению из файла, то
      $display($time, "BAD!  adr = %d, file = %h, memory = %h", adr, new_data, rd);  // сообщить об ошибке
    end                              
  end
  $fclose(file_mem);                  // закрыть файл
  $finish;                            // закончить симуляцию
end
```

## Задание по реализации памяти

1. На языке Verilog необходимо реализовать модуль памяти команд (Instruction Memory). Память представляет собой однопортовую ПЗУ с 256-ю 32-битными ячейками. Созданную память необходимо инициализировать любыми данными, после чего проверить в testbench, подавая случайные адреса на вход `A` и сравнивая данные на выходе `RD` с данными в файле инициализации.

**Примечание 1**: Под случайными адресами подразумевается просто набор любых адресов, разбросанных по всему объему памяти, который придёт вам в голову. Сравнение необходимо провести визуально.  

<details><summary> Примечания для любителей задачек со звездочкой:</summary>

  **Примечание 2:** если вы хотите воспринять задание буквально, для генерации случайных адресов можно воспользоваться системной функцией `$random`, генерирующей случайное знаковое целое 32-битное число. Для того, чтобы получить случайное число, лежащее в области допустимых значений адресов памяти, необходимо взять остаток от деления на старший адрес памяти +1. К примеру, для генерации случайного адреса из диапазона `[0:15]` необходимо можно использовать вызов `$random()%16`.  
  
  **Примечание 3:** вы можете воспринять задание еще более буквально и сравнивать данные на выходе `RD` с данными файлами инициализации автоматизировано, для этого вы можете воспльзоваться системными функциями `$fopen`, `$fread`, `$fclose`.

</details>

![Память инструкций](../../../technical/Labs/Pic/im.png)

2. На языке Verilog необходимо реализовать модуль памяти данных (Data Memory) для процессора с архитектурой RISC-V. Память представляет собой однопортовую ОЗУ с 256-ю 32-битными ячейками, но имеющая 32-битную шину адреса. То есть реально будет использоваться только ceil(log2(256)) = 8 из 32 битов входного адреса `RAM[A[9:2]]`, вместо `RAM[A]`. Созданную память необходимо проверить в testbench путем многократного выполнения последовательных операций: запись-чтение-сравнение. Разумеется что в пределах последовательности адрес должен быть одним и тем же, а между последовательностями адреса должны меняться.

> Необходимость использования 8 бит начиная со второго, а не нулевого бита `[9:2]` будет пояснена в 4-ой лабораторной работе. Если коротко, то это нужно для того, чтобы притвориться памятью размером в 4 гигабайта (на самом деле 1 килобайт) с побайтовой адресацией, будучи памятью с пословной адресацией (хранятся слова, а не байты). Так как в одно слово (32 бита) помещается 4 байта (по 8 бит), то на один адрес пословной памяти приходится по 4 адреса побайтовой. Значит для преобразования побайтового адреса в пословный его надо разделить на 4, что равносильно откидыванию 2 младших бит, поэтому `[9:2]`, а не `[7:0]`. Благодаря этому реализация первых 4-х лабораторных упрощается, но позже мы избавимся от этой памяти и заменим на соответствующую спецификации RISC-V.

![Память данных](../../../technical/Labs/Pic/dm.png)

3. На языке Verilog необходимо реализовать модуль регистрового файла (Register File) для процессора с архитектурой RISC-V, представляющего собой трехпортовую ОЗУ с двумя портами на чтение и одним портом на запись и состоящей из 32-х 32-битных регистров, при этом по адресу `0` не будет ячейки памяти и при чтении из нее всегда должен выдаваться 0. Для реализации такого функционала можно использовать тернарный оператор `A == 5'b0 ? /что-то/ : /что-то/`. Осуществить проверку модуля подобно проверке памяти данных.

![Регистровый файл](../../../technical/Labs/Pic/rf.png)

Разработанные блоки будут использованы при реализации процессора `CYBERcobra 3000 Pro 2.0` и последующих лабораторных для реализации системы с процессором с архитектурой RISC-V.
